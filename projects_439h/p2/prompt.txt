# CS439H Project 2

## Task
Implement cooperative multi-threading for an x86 kernel. Create a threading system with thread creation (thread<T>(T t)), blocking promises (Promise<T>), barriers, and context switching. Threads have 8KB stacks and yield cooperatively.

## Assignment Specification

Assignment:
~~~~~~~~~~~

    - Learn about C++ templates and lambdas (closures)
    - Implement cooperative multi-threading
    - Implement blocking promises and barriers
    - Deal with simple race conditions
    - Deal with resource (memory) leaks

Given:
~~~~~~

    - An incomplete single core implementation

Creating a thread:
~~~~~~~~~~~~~~~~~~

    template <typename T>
    void thread(T t) {   // T is a callable object
       ...
    }

Threads share global memory but have private stacks (8KB each)

Examples:

- using a C++ lambda

   thread([] {
       /* This code runs concurrently with the caller of "thread" */
       Debug::printf("hello from thread\n");
    });

- using a function

void body() {
    Debug::print("this is a thread\n");
}

void some_other_function() {
    ...
    thread(body);  // create a thread that runs the "body" function
    ...
}

Working with promises:
~~~~~~~~~~~~~~~~~~~~~~

- create a promise

Promise<int> p = new Promise<int>();

- getting the value from a promise

int v = p->get(); // blocks the caller until the value is set
                  // returns the value

- setting the value of a promise

p->set(10); // can only be set once

Working with barriers:
~~~~~~~~~~~~~~~~~~~~~~

- create a barrier

auto b = new Barrier(n);    // create a barrier that synchronizes 'n' threads

- synchronizing using a barrier

b->sync();  // the caller blocks until 'n' threads call sync on the same barrier
            // calling sync on the same barrier more than 'n' times is a programming error
Scheduling:
~~~~~~~~~~~

- Can't make any assumptions about the exact execution order
- All threads must get a chance to run (no thread starvation)
- All cores must participate in running ready threads
- No preemption, threads yield to each other using the "yield" call
Yielding the core:
~~~~~~~~~~~~~~~~~~

    void yield();  // let other threads run

Stopping a thread:
~~~~~~~~~~~~~~~~~~

    void stop();   // doesn't return, never run the calling thread again

Files you can change (without changing the API)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

kernel/threads.h
kernel/threads.cc
kernel/promise.h
kernel/promise.cc

## Workspace Files
The following files are in your workspace:
```
attach_qemu
debug_qemu
.gitignore
kernel/atomic.cc
kernel/atomic.h
kernel/barrier.cc
kernel/barrier.h
kernel/config.cc
kernel/config.h
kernel/context.S
kernel/crt.h
kernel/crti.cc
kernel/crtn.cc
kernel/debug.cc
kernel/debug.h
kernel/.gitignore
kernel/heap.cc
kernel/heap.h
kernel/idt.cc
kernel/idt.h
kernel/init.cc
kernel/init.h
kernel/io.h
kernel/kernel.h
kernel/libk.cc
kernel/libk.h
kernel/loop.h
kernel/machine.h
kernel/machine.S
kernel/Makefile
kernel/mbr.S
kernel/pit.cc
kernel/pit.h
kernel/promise.cc
kernel/promise.h
kernel/queue.h
kernel/random.h
kernel/script.ld
kernel/smp.cc
kernel/smp.h
kernel/snprintf.cc
kernel/threads.cc
kernel/threads.h
kernel/u8250.cc
kernel/u8250.h
Makefile
monitor_qemu
README
run_qemu
tools/summarize.py
```

There are 60 tests available. Tests are located in the `tests/` directory.

## Instructions
1. Read and understand all provided source files in your workspace.
2. Implement the required functionality by modifying the kernel source files.
3. To compile and test, use the `./exec` wrapper which runs commands in a Linux
   environment with all necessary tools:
   - `./exec 'make'` — compile
   - `./exec 'make -s test'` — run all tests
4. You can edit files directly — they are shared with the build environment.
5. The kernel runs in QEMU (i386, 4 cores, 128MB RAM). Tests timeout after 10 seconds.
6. This is a freestanding kernel — no libc. Use only what's provided.
7. Focus on correctness first. Concurrency bugs and race conditions are the main challenge.
8. Your primary goal is to pass ALL test cases. Partial solutions are not acceptable — strive to make every single test pass.
9. You may create your own test files (`.cc` and `.ok`) in the `tests/` directory to help debug your implementation.
10. A grading tool is available at `./grade`. After building, run `./exec './grade -n 10'` to run each test 10 times and check for flaky concurrency bugs. Your final grade depends on test reliability — tests must pass consistently, not just once.

## Constraints
- Do NOT modify the Makefile or kernel/Makefile.
- Do NOT modify the README.
- Do NOT modify test files (.ok files, .dir directories).
- Do NOT modify kernel infrastructure files unless the README says you can:
  - Leave alone: kernel/machine.h, kernel/machine.S, kernel/script.ld
- You may create new source files in the kernel/ directory if needed.
- The code must compile without warnings (`-Wall -Werror` is enabled).
