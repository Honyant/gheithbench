* discuss how your design/implementation handles all constraints
     - critical sections using spinning are O(1)
     - critical sections using interrupts are O(1)
     - interrupts are always disabled when an interrupt frame is on the active stack

I make sure that I never have any spinlocks within a spinlocked section. Because interrupts are also disabled within a spinlock, this guarentees that there won't be any interrupts that could potentially take more than o(1). I make sure not to lock over sections that need to interact with the ready queue.


I use busy flags to prevent preemption but allow interrupts, so interrupts can still happen and jiffies can still be updated. It's ok to be interrupted in most places as long as you return to the same core.
The only time interrupts need to be disabled and where busy flags aren't sufficient is when an interrupt handler is running, and when getting current_thread[SMP::me()].
I make sure that I never have any spinlocks within an interrupt handler (which is the only time that interrupts need disabled), and that any o(n) work that needs to be done is in the offline interrupt handler.

I make sure that interrupts are always disabled when an interrupt frame is on the stack by context switching to an offline interrupt handler in the interrupt handler. This way, the interrupt handler will never be interrupted by another interrupt handler, and any potential o(n) work will be done in the offline interrupt handler, on a different stack.


* why do we need both strong and weak references?

If we have a strong pointer and another strong pointer point to each other, they will always be alive because they point to each other-there is a cycle. If we have a weak pointer, it will be deallocated when the strong pointer is deallocated. This is useful for breaking cycles.
