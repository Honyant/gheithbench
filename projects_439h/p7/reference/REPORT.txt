- What does "switchToUser" do? Explain every instruction and why it's there

  switchToUser:
    mov 4(%esp),%ecx        # get this pc arg from stack and put into ecx, so we can push it last
    mov 8(%esp),%ebx        # get this esp from stack and put into ebx, so we can push it later
    mov 12(%esp),%eax       # eax is the standard return reg, we can put data in here if the user program somehow expects a return value but in our case we don't really use this
    pushl userSS            # user SS indicates privlege level of the userStack, and we push it here
    pushl %ebx              # push the user esp onto the stack
    pushf                   # push flags onto the stack
    orl $0x200,(%esp)       # we just pushed the flags register onto the stack, we make sure to turn interrupts on by setting the IF
    pushl userCS            # pushed the userCs to make sure we only have user perms
    pushl %ecx              # push the desired user pc
    iret                    # pops everything off the stack into their respective registers and jumps to the user pc


- Trace the execution of the "write" system call
  starting from user/init.c calling "write" until the
  number of written bytes is returned.

  Make sure you list every function entered and what
  it does.

  Make sure you also list control transfers that are
  not function calls and why they're needed

User Space Execution (user/init.c):
write(1, "Hello, world!\n", 14);


Program makes the write() system call with parameters:
fd = 1 (stdout)
buf = pointer to "Hello, world!\n"
count = 14 bytes
System Call Setup (user/sys.S):
write:
    mov $4,%eax      # Load system call number (4) into eax
    int $48          # Generate interrupt 48 (transfer to kernel)
    ret             # Return to caller after system call completes


This loads system call number and triggers the interrupt, and the control transfers to kernel

sysHandler_:
    push %esp
    push %eax
    .extern sysHandler
    call sysHandler
    add $8,%esp
    iret

In the kernel, the system call handler is called in machine.S.
it pushes the user stack pointer and system call number onto the stack, calls sysHandler in kernel/sys.cc, pops the arguments off the stack, and returns to user space.

System Call Handler (kernel/sys.cc):
int sysHandler(uint32_t eax, uint32_t* frame) {
    // Get user stack pointer from frame
    uint32_t* userStack = reinterpret_cast<uint32_t*>(frame[3]) + 1;
    
    // Validate user stack address
    if (userStack < (uint32_t*)0x80000000) {
        return -1;
    }

    // Handle write system call (eax = 1)
    if (eax == 1) {
        int fd = *userStack;
        void* buf = reinterpret_cast<void*>(*(userStack + 1));
        uint32_t nbyte = *(userStack + 2);
        return write(fd, buf, nbyte);
    }
}


Write Implementation (kernel/sys.cc):

uint32_t write(int fd, void* buf, size_t nbyte) {
    // Validate file descriptor
    if (fd < 0 || fd >= 100) return -1;
    
    // Check buffer address ranges
    if (overlap(...)) return -1;
    
    // Get file descriptor table
    auto fdt = impl::threads::state.current()->file_descriptors;
    int id = findIdFile(fd, fdt);
    if (id == -1) return -1;
    
    // Check write permission
    if (!fdt[id].file->canWrite) return -1;
    
    // Handle stdout/stderr
    if (fdt[id].file->isStdout || fdt[id].file->isStderr) {
        for (uint32_t i = 0; i < nbyte; i++) {
            Debug::printf("%c", ((char*)buf)[i]);
        }
        return nbyte;
    }
    
    return 0;
}


Return Path:
Write function returns number of bytes written
System handler returns this value to user space
CPU restores user context
Execution continues in user space after the system call

Key Control Transfers:
User -> Kernel: via int $48 instruction (hardware interrupt)
Switches to kernel stack, changes privilege level, and saves context. Needed because user space cannot access hardware directly
Kernel -> User: via iret instruction (implicit)
Switches back to user stack, changes privilege level, restores context, and resumes execution. Needed to return to user space after system call, with correct state


- What is the difference between fileSize and memSize
  in kernel/elf.cc?

fileSize is the size of the actual executable program and nonzero data. memsize is how much needs to be mmapped, and so everything that is in the (fileSize, memSize) interval needs to be zero.

- How come we don't have t0.cc? Where does the test come
  from?

We don't have t0.cc because we are testing that we can load in programs and run them in our kernel, and we are not compiling anything for our test cases.
The test case comes from the user who writes the test case, who is responsible for compiling it into a binary.
We look for /sbin/init in our kernel.cc, and then we load that user test case in then it can test syscalls.

- All system call stubs in t0.dir/sbin/sys.S follow the same pattern
  except for "fork". Why is it different?

Regular syscalls don't need to save the calle-saved registers: ebx, esi, edi, and ebp because the kernel's syscall handler automatically preserves them. Fork spawns a new child that starts executing from the same point, BUT on the new stack for the new TCBWithWork's new stack, which we aren't duplicating because that would be a pain and we'd probably have to write fork mostly in asm, so fork's stub explicitly saves and restores the callee-saved registers here. Key thing is that we are on a new kernel stack so we don't have the same stack as the parent, so we won't have the same values in the callee-saved registers.

fork is 
	# int fork()
	.global fork
fork:
	push %ebx
	push %esi
	push %edi
	push %ebp
	mov $2,%eax
	int $48
	pop %ebp
	pop %edi
	pop %esi
	pop %ebx
	ret

	# int sem(uint32_t init)
	.global sem
sem:
	mov $3,%eax
	int $48
	ret
