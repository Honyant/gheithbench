# CS439H Project 7

## Task
Add user-mode process support to the kernel. Implement an ELF loader, system call dispatcher (open, read, write, close, exit, fork, exec, wait, etc.), and privilege-level switching (ring 0 ↔ ring 3). The kernel boots /sbin/init from the ext2 filesystem.

## Assignment Specification

Assignment:
~~~~~~~~~~~

- Go to user mode
- Implement the required system calls

What can you change:
~~~~~~~~~~~~~~~~~~~~

- The kernel is yours, you can do anything with it as long as:

     * you leave the Makefile's alone
     * you leave the kernel link script alone
     * it continues to implement preemptive multi-threading with
       the informal liveness semantics:
            o All cores get to participate
            o All threads get a fair share of resources
     * it adheres to the user contract:
            o The virtual address space structure
            o Protects the kernel from user processes
            o Protects user processes from each other
            o Implements the system call semantics
            o Bootstraps the process tree from /sbin/init

The given code:
~~~~~~~~~~~~~~~

There is enough code in kernel/ to bootstrap the first user process but:

     o The file system and virtual memory implementations are incomplete
        and in some places incorrect (e.g. look for prints tagged with
        FIXME). You are responsible for making them work.

     o You can use any parts of the code you want for this (and future)
       assignments but you can't copy it in late submissions for previous
       assignments.

     o You need to understand everything you submit.

Virtual Address Space:
~~~~~~~~~~~~~~~~~~~~~~

0x00000000 - 0x00001000       (invalid)
0x00001000 - 0x80000000       (shared kernel RWX)
0x80000000 - 0xF0000000       (process private, user RWX)
0xF0000000 - 0xFFFFFFFF+1     (shared, user RWX except for the PICS, kernel RW)

User code should not be able to access anything outside loaded or mmaped regions in
the user range. All other memory references should the process to exit with exit code (-1)

Details:
~~~~~~~~

(1) kernelMain mounts the ext2 file system in drive #1

(2) it looks for a file named /sbin/init

(3) it loads it in user memory (0x80000000 - 0xf0000000) according to what
    the ELF file asks for.

    It should reject any non-ELF files or an ELF file that tries to load
    a program outside the user range

(4) it switches to user mode and starts running the user process at the
    program entry point

(5) the kernel should protect all its resources from the user program

(6) Look in t0.dir/bin/sys.h and t0.dir/bin/sys.S for details about most
    of the required system calls

(7) 3 system calls are required but not included in t0:

    // Syscall#100
    int chdir(const char* path); // changes the current working directory
                                 // to the given path.
                                 // returns 0 on success, -1 on error.

    // Syscall#101
    // maps to the in-kernel implementation of naive_mmap as defined in p6
    void* naive_mmap(uint32_t size,
             int is_shared,
             int file,
             uint32_t offset);

    // Syscall#102
    // maps to the in-kernel implementation of naive_unmap as defined in p6
    void naive_unmap(void* p); 
    
                                   

files:
~~~~~~

- kernel/          contains the kernel files

- <test>.dir/      the contents of the root disk

- <test>.dir/sbin
    init.c         ... init source
    libc.c/libc.h  ... minimal libc implementation
    sys.s/sys.h    ... user-side system calls
    init           ... the elf init file packaged in t0.img

for makefile help:
~~~~~~~~~~~~~~~~~~

    make help

to run test:
~~~~~~~~~~~~

    make -s clean test

to run one test:
~~~~~~~~~~~~~~~~

    make -s t0.test

To make the output more noisy:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    make clean test

To run by hand
~~~~~~~~~~~~~~

    ./run_qemu t0

To attach with gdb
~~~~~~~~~~~~~~~~~~

    ./debug_qemu t0

## Workspace Files
The following files are in your workspace:
```
attach_qemu
debug_qemu
.gitignore
kernel/atomic.cc
kernel/atomic.h
kernel/barrier.cc
kernel/barrier.h
kernel/bb.h
kernel/blocking_lock.h
kernel/blocking_queue.h
kernel/block_io.cc
kernel/block_io.h
kernel/buffer_cache.h
kernel/buffer.h
kernel/config.cc
kernel/config.h
kernel/context.S
kernel/crt.h
kernel/crti.cc
kernel/crtn.cc
kernel/debug.cc
kernel/debug.h
kernel/elf.cc
kernel/elf.h
kernel/ext2.cc
kernel/ext2.h
kernel/.gitignore
kernel/heap.cc
kernel/heap.h
kernel/ide.cc
kernel/ide.h
kernel/idt.cc
kernel/idt.h
kernel/init.cc
kernel/init.h
kernel/io.h
kernel/kernel.cc
kernel/kernel.h
kernel/libk.cc
kernel/libk.h
kernel/loop.h
kernel/machine.h
kernel/machine.S
kernel/Makefile
kernel/mbr.S
kernel/physmem.cc
kernel/physmem.h
kernel/pit.cc
kernel/pit.h
kernel/promise.cc
kernel/promise.h
kernel/queue.h
kernel/random.h
kernel/script.ld
kernel/semaphore.h
kernel/shared.cc
kernel/shared.h
kernel/smp.cc
kernel/smp.h
kernel/snprintf.cc
kernel/sys.cc
kernel/sys.h
kernel/threads.cc
kernel/threads.h
kernel/tss.h
kernel/u8250.cc
kernel/u8250.h
kernel/utils.h
kernel/vme.cc
kernel/vme.h
kernel/vmm.cc
kernel/vmm.h
Makefile
monitor_qemu
README
run_qemu
```

There are 49 tests available. Tests are located in the `tests/` directory.

## Instructions
1. Read and understand all provided source files in your workspace.
2. Implement the required functionality by modifying the kernel source files.
3. To compile and test, use the `./exec` wrapper which runs commands in a Linux
   environment with all necessary tools:
   - `./exec 'make'` — compile
   - `./exec 'make -s test'` — run all tests
4. You can edit files directly — they are shared with the build environment.
5. The kernel runs in QEMU (i386, 4 cores, 128MB RAM). Tests timeout after 10 seconds.
6. Tests provide an ext2 disk image containing /sbin/init (a user-mode ELF binary).
7. The kernel builds a single kernel.img used for all tests. Each test provides a different filesystem.
8. This is a freestanding kernel — no libc. Use only what's provided.
9. Focus on correctness. System call handling and privilege switching are the main challenges.
10. Your primary goal is to pass ALL test cases. Partial solutions are not acceptable — strive to make every single test pass.
11. You may create your own test files (`.ok` and `.dir` with `/sbin/init`) in the `tests/` directory to help debug your implementation.
12. A grading tool is available at `./grade`. After building, run `./exec './grade -n 10'` to run each test 10 times and check for flaky concurrency bugs. Your final grade depends on test reliability — tests must pass consistently, not just once.

## Constraints
- Do NOT modify the Makefile or kernel/Makefile.
- Do NOT modify the README.
- Do NOT modify test files (.ok files, .dir directories).
- Do NOT modify kernel infrastructure files unless the README says you can:
  - Leave alone: kernel/machine.h, kernel/machine.S, kernel/script.ld
- You may create new source files in the kernel/ directory if needed.
- The code must compile without warnings (`-Wall -Werror` is enabled).
