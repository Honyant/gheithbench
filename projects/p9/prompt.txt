# CS429H Project 9

## Task
Complete a pipelined implementation of a simple 16-bit CPU in Verilog. The ISA includes sub, movl, movh, jz, jnz, js, jns, and ld instructions. Do whatever it takes to minimize cycles per instruction. Do not finish until score maximized. DON'T GIVE UP. Use check_performance.py and cycles_reference.json to see how your cycle counts compare to optimized baselines, and verify that these scripts work early on. Top quartile (score 90-100) requires excellent pipelining and hazard handling. A branch predictor is necessary.

## Assignment Specification
Assignment:

(1) Finish a pipelined implementation of a simple instruction set.

    Please look carefully at mem.v and regs.v, leave both the interface
    and timing alone.

Architecture
~~~~~~~~~~~~

  - memory is byte addressable

  - words are 16 bits (little-endian)

  - 16 register names r0, r1, ..., r15 (16 bits each)
  
  - r0 is special:
      * reading from r0 always returns 0
      * writing to r0 interprets the the least significant
        8 bits as an ASCII code and prints that character

  - all instructions are 16 bit wide

  encoding          instruction   description
    
  0000aaaabbbbtttt  sub rt,ra,rb  regs[t] = regs[a] - regs[b]

  yes  movl rt,i     regs[t] = sign_extend(i)
  1001iiiiiiiitttt  movh rt,i     regs[t] = (regs[t] & 0xff) | (i << 8)

  1110aaaa0000tttt  jz rt,ra      pc = (regs[ra] == 0) ? regs[rt] : pc + 2
  1110aaaa0001tttt  jnz rt,ra     pc = (regs[ra] != 0) ? regs[rt] : pc + 2
  1110aaaa0010tttt  js rt,ra      pc = (regs[ra] < 0) ? regs[rt] : pc + 2
  1110aaaa0011tttt  jns rt,ra     pc = (regs[ra] >= 0) ? regs[rt] : pc + 2

  1111aaaa0000tttt  ld rt,ra      regs[t] = mem[regs[a]]
  1111aaaa0001tttt  st rt,ra      mem[regs[a]] = regs[t]


  Any illegal instruction halts the processor by asserting the
  halt signal. This also terminates the simulation.

  Please notice that the "counter" modules prints the number of elapsed
  cycles before calling "$finish". This is required in order to measure
  the CPI.


Files you can change
~~~~~~~~~~~~~~~~~~~~

cpu.v contains an incomplete processor design


Files you need to leave alone
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

mem.v
regs.v
counter.v
clock.v

The make targets/files:
~~~~~~~~~~~~~~~~~~~~~~~

    <test name>.raw        => the raw output from running the test
    <test name>.out        => lines from *.raw that start with #
    <test name>.cycles     => number of cycles needed to run the test
    <test name>.vcd        => vcd file after running test
    <test name>.ok         => expected output
    <test name>.hex        => the test program

## Workspace Files
The following files are in your workspace:
```
check_performance.py
clock.v
counter.v
cpu.v
cycles_reference.json
Makefile
mem.v
README
regs.v
```

There are 56 tests available. Tests are located in the `tests/` directory (or flat in the workspace for P5).

## Instructions
1. Read and understand all provided source files in your workspace.
2. Implement the required functionality by modifying the source files.
3. To compile and test, use the `./exec` wrapper which runs commands in a Linux
   environment with all necessary tools:
   - `./exec 'make'` — compile
   - `./exec 'make -s test'` — run all tests
   - `./exec './cpu'` — run the CPU binary
   - `./exec 'python3 check_performance.py'` — check your cycle performance
4. You can edit files directly — they are shared with the build environment.
5. `iverilog` is available in the build environment.
6. Use check_performance.py after running tests to see how your cycles compare.
7. cycles_reference.json contains min/q1/median/q3/avg for each test from optimized implementations.
8. Focus on correctness first, then optimize for performance.

## Constraints
- Do NOT modify the Makefile, README, or any test files (.ok files).
- Do NOT modify the REPORT.txt file.
- You may create new source files if needed, but prefer modifying existing ones.
- The code must compile without warnings (`-Wall -Werror` is enabled).
